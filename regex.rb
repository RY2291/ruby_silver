# 正規表現オブジェクト
  # 「/」で囲んだり、%rからパターンを開始することで正規表現のオブジェクトを生成できる。
  p /Ruby/
  p %r(Ruby)
  p Regexp.new "Ruby"

  # マッチした箇所を取得
    # 「=~」でマッチした箇所を取得できる。マッチした文字列のインデックスを返す。
    p /Ruby/ =~ "I love Ruby"

  # マッチした文字列を取り出す
    # =~と同じスコープで組み込み変数「$&」を参照する
    /bb/ =~ "aabbcc"
    p $&

  # マッチした文字列より前の文字列を参照する
    # 「$`」を使用する
    p $`

  # マッチした文字列より後の文字列を参照する
    # 「$'」を使用する
    p $'

  # 行頭 => ^

  # 行末 => $

  # いずれかを満たす場合には、「|」で区切る。優先度が低いにので()を付ける。
    reg = /^(aa|bb)c$/
    p reg === "aac"
    p reg === "abc"
    p reg === "bbc"

  # 文字の集合を指定するには、文字を「[]」で囲う。
    reg = /a[bcd]e[fg]h/ # => []内、１文字しか指定できない
    p reg === "abegh"
    p reg === "abcegh"


# 正規表現記号とオプション
  # 連続する値を指定 => 「-」を使用。
  p /a[1-5]z/ === "a2z"

  # 正規表現記号
    # .  => 改行を除く任意の１文字。ｍオプションが指定された場合は、改行もマッチする。
    # \d => 数字
    # \D => 数字以外の文字
    # \w => 英数字とアンダースコア
    # \W => 英数字とアンダースコア以外の文字
    # \s => 空白文字（\t, \n, \f, \f）
    # \S => 空白文字以外
    # \A => 先頭の文字。改行の有無に影響されない。
    # \z => 末尾の文字。改行の有無は影響されない。
    # \Z => 末尾の文字。改行で終わっていれば、その改行の直前にマッチ。
    p /a\db/ === "a2b"
    p /a\Db/ === "a-b"
    p /b\wb/ === "bkb"
    p /c\sv/ === "c v"

    p "=========================="
  # 繰り返しを表現する正規表現記号
    # *   => 直前の文字の０回以上の繰り返し
      p /a*b/ === "b"
      p /a*b/ === "aaaaaab"
    # +   => 直前の文字の1回以上の繰り返し
      p /a+b/ === "aab"
      p /a+bc/ === "bc"
    # {m} => 直前の文字のｍ回繰り返し
      p /a{3}b/ === "aaaaaaaaaab"
      p /a{2}b/ === "ab"
    # {m,} => 直前の文字の最低ｍ回の繰り返し
      p /a{2,}b/ === "ab"
      p /a{2,}b/ === "aaab"
    # {m,n} => 直前の文字の最低ｍ回、最高ｎ回の繰り返し
      p /a{2,4}b/ === "aaaaab"
      p /a{2,4}b/ === "aaaab"

  # 正規表現のグループ化
    # パターンを丸括弧()で囲む。文字列の繰り返しもできる。
      p /a(bc)*d/ === "abcbcd"

p "==================================="

p /a./ === "az"
p /a*/ === "aaaaaaaa"
p /a.+/ === "abbbb"
p /\da/ === "2a"
p /\Dv/ === "av"
p /1\d{4}/ === "17777"
p /\w{2,5}/ === "aaaaa"
p /\s{2,}/ === "   "