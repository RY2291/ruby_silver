# UFO演算子
  # 比較の結果を数値で返す
  # 左辺 > 右辺 => 1, 左辺 < 右辺 => -1, 左辺 == 右辺 => 0
  p 100 <=> 10
  p 10 <=> 100
  p 100 <=> 100

# 正規表現メタ文字
  # []で囲むと[]内のいずれかにマッチするという表現
    # [a-z] => abcdefghijklmnopqrstuvwxyz
    # [A-Z] => ABCDEFGHIJKLMNOPQRSTUVWXYZ
    # [0-9] => 0123456789

  # .は改行以外の文字にマッチします。mオプションがあると改行にもマッチします。
  p /./ =~ "\nRuby"

# Array#each_slice(n)は、selfからn個で配列を区切りブロックに渡す。
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  arr.each_slice(3) do |i|
    p i
  end
  # [1, 2, 3][4, 5, 6][7, 8, 9][10]


# equal?メソッド
  # ２つのオブジェクトが同一かどうか(オブジェクトIDが同じかどうか)
  a1 = "abc"
  a2 = "abc"
  p a1.equal? a2

# 等価演算子（==）
  # 2つのオブジェクトが等しいかどうか
  p a1 == a2

# eql?
  # 型の比較も行うため、値が等しくても型が異なる場合は、falseを返す。
  p a1.eql? a2


# productメソッド
  # レシーバーの配列と引数の配列からそれぞれ1つ要素を取り出し新しい配列を作成し、全ての配列を要素とする配列を返す。
  p [1, 2].product([3, 4])

# transposeメソッド
  # レシーバーの配列から行と列を入れ替えた配列を作成し返す。
  arr = [1,2].product([3,4]).transpose
  p arr

# 配列の和集合（|）
  # ２つの配列の要素を全て集めて、重複しないように返す
  a = [1, 2, 3]
  b = [3, 4, 5]
  p a | b

# 配列の差集合（-）
  # 左の配列から右の配列に含まれる要素を取り除く
  p a - b

# 配列の積集合（&）
  # 2つの共通する要素を返す
  p a & b

# invertメソッド
  # キーと値を入れ替えて、入れ替えの結果キーが重複していた場合は、後に定義された方が優先される
  p ({a: 100, b: 100}).invert


# subメソッド
  # 第１引数の検索対象パターンと、第２引数の置換後の文字列を使用して1回だけレシーバの文字列を置換する。
  p "Hi, I love Ruby.".sub(/[A-Z]/, "*") 


# フォーマット文字列
  # %x	日付(%m/%d/%y)
  # %m	月を表す数字(01-12)
  # %M	分(00-59)
  # %d	日(01-31)
  # %D	日付(%m/%d/%y)
  # %y	西暦の下2桁(00-99)
  # %Y	西暦を表す数(9999)

# injectメソッド
  # レシーバの要素に対して引数で指定した処理を行う。
  p [1, 2, 3].inject(:+)

# splitメソッド
  # 引数の正規表現にマッチしたもので文字列を分解する
  p "Spring,Summer,Autumn,Winter".split(/,/)

  # また、（）があると、マッチしたものを含んだ結果を返す
  p "Spring,Summer,Autumn,Winter".split(/(,)/)

